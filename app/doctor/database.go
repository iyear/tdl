package doctor

import (
	"context"
	"os"

	"github.com/fatih/color"
	"github.com/spf13/viper"

	"github.com/iyear/tdl/core/storage"
	"github.com/iyear/tdl/pkg/consts"
	"github.com/iyear/tdl/pkg/key"
)

func checkDatabaseIntegrity(ctx context.Context, opts Options) {
	storage := opts.KV
	if storage == nil {
		color.Red("  [FAIL] Storage not initialized")
		return
	}

	// Check storage type
	storageType := storage.Name()
	color.White("  Storage type: %s", storageType)

	// Get storage configuration
	storageConfig := viper.GetStringMapString(consts.FlagStorage)

	// Check if storage path exists and is accessible
	path := storageConfig["path"]
	if path == "" {
		color.Yellow("  [WARN] Storage path not configured")
	} else {
		color.White("  Storage path: %s", path)

		// Check if path exists
		if info, err := os.Stat(path); err != nil {
			if os.IsNotExist(err) {
				color.Yellow("  [WARN] Storage path does not exist yet (will be created on first use)")
			} else {
				color.Red("  [FAIL] Cannot access storage path: %v", err)
				return
			}
		} else {
			// Show basic info about the storage
			if info.IsDir() {
				color.White("  Storage is a directory")
			} else {
				color.White("  Storage is a file (size: %d bytes)", info.Size())
			}
		}
	}

	// Check namespaces using already-opened storage
	// This is safe because we're using the storage instance that was opened by root command
	namespaces, err := storage.Namespaces()
	if err != nil {
		color.Red("  [FAIL] Failed to list namespaces: %v", err)
		return
	}

	if len(namespaces) == 0 {
		color.Yellow("  [WARN] No namespaces found in storage")
	} else {
		color.White("  Found %d namespace(s): %v", len(namespaces), namespaces)
	}

	// Check current namespace has required keys
	currentNS := viper.GetString(consts.FlagNamespace)
	if currentNS != "" {
		color.White("  Current namespace: %s", currentNS)

		nsStorage, err := storage.Open(currentNS)
		if err != nil {
			color.Yellow("  [WARN] Failed to open namespace '%s': %v", currentNS, err)
		} else {
			checkNamespaceKeys(ctx, nsStorage)
		}
	}

	color.Green("  [OK] Database integrity check passed")
}

func checkNamespaceKeys(ctx context.Context, storage_ interface{}) {
	type getter interface {
		Get(ctx context.Context, key string) ([]byte, error)
	}

	st, ok := storage_.(getter)
	if !ok {
		return
	}

	// Check for session key (generated by keygen.New("session"))
	a := storage.Session{}
	if _, err := st.Get(ctx, a.Key()); err == nil {
		color.White("    - Session data: present")
	} else {
		color.Yellow("    - Session data: missing (not logged in)")
	}

	// Check for app key
	if data, err := st.Get(ctx, key.App()); err == nil {
		color.White("    - App config: present (%s)", string(data))
	} else {
		color.Yellow("    - App config: missing")
	}
}
